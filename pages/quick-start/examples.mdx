# Real-World Examples

Learn from complete implementations of common Inngest use cases. Each example demonstrates production-ready patterns with full function code, event schemas, error handling, and best practices. These examples showcase how to build robust, scalable workflows that handle real business requirements.

## User Onboarding Sequence

**What it does**: Creates an intelligent email onboarding flow that adapts based on user behavior, handles activation timeouts, and personalizes content based on engagement levels.

**When to use**: Customer onboarding, user activation campaigns, trial-to-paid conversion flows, or any multi-step user journey that needs to react to user behavior over time.

### Key Features

| Feature | Description | Business Value |
|---------|-------------|----------------|
| **Behavioral Adaptation** | Waits for user activation and adjusts messaging accordingly | Higher activation rates through personalized timing |
| **Timeout Handling** | Automatically handles users who don't activate within timeframes | Prevents lost users with strategic re-engagement |
| **Engagement Scoring** | Measures user activity and tailors advanced content | Improves feature adoption and user retention |
| **Concurrency Control** | Prevents duplicate workflows per user | Ensures consistent user experience |
| **Flexible Timing** | Uses `waitForEvent` with timeouts for responsive flows | Balances immediate response with patience |

### Workflow Steps

1. **Immediate Welcome** - Send welcome email with plan-specific content
2. **Activation Wait** - Wait 24 hours for user to activate their account
3. **Activation Check** - Verify if user activated, send reminders if not
4. **Activation Response** - Wait for activation event with 3-day timeout
5. **Onboarding Continuation** - Send getting started guide after 2-day delay
6. **Engagement Analysis** - Measure user activity over 7 days
7. **Personalized Follow-up** - Send tips for low engagement or advanced features for high engagement

### Use Cases
- **SaaS Trial Onboarding**: Guide trial users to key features and conversion
- **E-learning Platforms**: Adapt course recommendations based on progress
- **Marketplace Onboarding**: Help new sellers complete profile setup and first listing
- **Mobile App Onboarding**: React to user permissions and feature usage

```typescript
// Event types
type UserSignupEvent = {
  name: "user/signup";
  data: {
    userId: string;
    email: string;
    name: string;
    plan: "free" | "pro" | "enterprise";
  };
};

type UserActivatedEvent = {
  name: "user/activated";
  data: {
    userId: string;
    activatedAt: string;
  };
};

// Main onboarding function
export const userOnboarding = inngest.createFunction(
  { 
    id: "user-onboarding",
    concurrency: { limit: 100, key: "event.data.userId" }
  },
  { event: "user/signup" },
  async ({ event, step }) => {
    const { userId, email, name, plan } = event.data;

    // Send immediate welcome email
    await step.run("send-welcome-email", async () => {
      return await emailService.send({
        to: email,
        template: "welcome",
        data: { name, plan }
      });
    });

    // Wait 1 day for user to activate
    await step.sleep("wait-for-activation", "1d");

    // Check if user activated their account
    const user = await step.run("check-activation", async () => {
      return await database.users.findById(userId);
    });

    if (!user.isActivated) {
      // Send activation reminder
      await step.run("send-activation-reminder", async () => {
        return await emailService.send({
          to: email,
          template: "activation-reminder",
          data: { name, activationLink: user.activationLink }
        });
      });

      // Wait for activation event or timeout after 3 days
      const activationEvent = await step.waitForEvent("wait-for-activation-event", {
        event: "user/activated",
        timeout: "3d",
        if: `event.data.userId == "${userId}"`
      });

      if (!activationEvent) {
        // User never activated - send final reminder
        await step.run("send-final-reminder", async () => {
          return await emailService.send({
            to: email,
            template: "final-activation-reminder",
            data: { name }
          });
        });
        return { status: "not_activated" };
      }
    }

    // User is activated - continue onboarding
    await step.sleep("wait-2-days", "2d");

    // Send getting started guide
    await step.run("send-getting-started", async () => {
      return await emailService.send({
        to: email,
        template: "getting-started",
        data: { name, plan }
      });
    });

    // Wait 1 week
    await step.sleep("wait-1-week", "7d");

    // Check user engagement
    const engagement = await step.run("check-engagement", async () => {
      return await analytics.getUserEngagement(userId, "7d");
    });

    if (engagement.score < 0.3) {
      // Low engagement - send tips email
      await step.run("send-engagement-tips", async () => {
        return await emailService.send({
          to: email,
          template: "engagement-tips",
          data: { name, unusedFeatures: engagement.unusedFeatures }
        });
      });
    } else {
      // High engagement - send advanced features
      await step.run("send-advanced-features", async () => {
        return await emailService.send({
          to: email,
          template: "advanced-features",
          data: { name, plan }
        });
      });
    }

    return { 
      status: "completed",
      engagementScore: engagement.score 
    };
  }
);
```

## E-commerce Order Processing

**What it does**: Orchestrates complete order fulfillment from payment processing through shipping, with comprehensive error handling and customer communication.

**When to use**: E-commerce platforms, marketplace transactions, subscription services, or any business that needs to coordinate payment, inventory, and fulfillment processes.

### Key Features

| Feature | Description | Business Value |
|---------|-------------|----------------|
| **Atomic Operations** | Each step is isolated and retryable | Prevents partial order states and data corruption |
| **Inventory Management** | Checks availability and reserves items | Prevents overselling and inventory conflicts |
| **Payment Processing** | Secure payment with comprehensive error handling | Reduces payment failures and chargebacks |
| **Multi-Service Coordination** | Integrates payment, inventory, shipping, and notifications | Creates seamless customer experience |
| **Automatic Recovery** | Handles failures at any step with appropriate cleanup | Minimizes manual intervention and support tickets |

### Workflow Steps

1. **Order Validation** - Verify order data, addresses, and business rules
2. **Inventory Check** - Confirm all items are available for purchase
3. **Payment Processing** - Charge customer with retry logic and error handling
4. **Inventory Reservation** - Lock items for this order to prevent overselling
5. **Shipping Calculation** - Determine shipping costs and delivery estimates
6. **Shipment Creation** - Generate shipping labels and tracking numbers
7. **Order Status Update** - Update database with payment and shipping information
8. **Customer Notification** - Send confirmation email with tracking details
9. **Follow-up Scheduling** - Schedule post-delivery customer satisfaction check

### Use Cases
- **E-commerce Stores**: Complete order-to-delivery automation
- **B2B Marketplaces**: Handle complex multi-vendor order processing
- **Subscription Boxes**: Coordinate inventory, packing, and shipping workflows
- **Digital + Physical Products**: Mix downloadable and shippable items

### Error Handling Strategy

- **Validation Failures**: Immediately reject with detailed error messages
- **Inventory Issues**: Cancel order and notify customer with alternatives
- **Payment Failures**: Retry with backoff, then cancel order gracefully
- **Shipping Problems**: Retry shipping creation, fallback to manual processing

```typescript
type OrderCreatedEvent = {
  name: "order/created";
  data: {
    orderId: string;
    userId: string;
    items: Array<{
      productId: string;
      quantity: number;
      price: number;
    }>;
    total: number;
    paymentMethodId: string;
    shippingAddress: {
      street: string;
      city: string;
      state: string;
      zip: string;
      country: string;
    };
  };
};

export const processOrder = inngest.createFunction(
  {
    id: "process-order",
    concurrency: { limit: 20 },
    retries: 3
  },
  { event: "order/created" },
  async ({ event, step, logger }) => {
    const { orderId, userId, items, total, paymentMethodId, shippingAddress } = event.data;
    
    logger.info("Processing order", { orderId, userId, total });

    // Step 1: Validate order
    const validation = await step.run("validate-order", async () => {
      return await orderValidator.validate({
        items,
        total,
        shippingAddress
      });
    });

    if (!validation.valid) {
      throw new Error(`Order validation failed: ${validation.errors.join(", ")}`);
    }

    // Step 2: Check inventory
    const inventory = await step.run("check-inventory", async () => {
      return await inventoryService.checkAvailability(items);
    });

    if (!inventory.available) {
      await step.run("notify-out-of-stock", async () => {
        return await notificationService.send({
          userId,
          type: "order_cancelled",
          data: { orderId, reason: "out_of_stock", unavailableItems: inventory.unavailableItems }
        });
      });
      throw new Error(`Items out of stock: ${inventory.unavailableItems.join(", ")}`);
    }

    // Step 3: Process payment
    const payment = await step.run("process-payment", async () => {
      try {
        return await paymentService.charge({
          amount: total,
          paymentMethodId,
          metadata: { orderId }
        });
      } catch (error) {
        logger.error("Payment failed", { orderId, error: error.message });
        throw error;
      }
    });

    // Step 4: Reserve inventory
    await step.run("reserve-inventory", async () => {
      return await inventoryService.reserve(items, orderId);
    });

    // Step 5: Calculate shipping
    const shipping = await step.run("calculate-shipping", async () => {
      return await shippingService.calculateRates({
        items,
        destination: shippingAddress
      });
    });

    // Step 6: Create shipment
    const shipment = await step.run("create-shipment", async () => {
      return await shippingService.createShipment({
        orderId,
        items,
        destination: shippingAddress,
        service: shipping.recommendedService
      });
    });

    // Step 7: Update order status
    await step.run("update-order-status", async () => {
      return await database.orders.update(orderId, {
        status: "processing",
        paymentId: payment.id,
        trackingNumber: shipment.trackingNumber
      });
    });

    // Step 8: Send confirmation email
    await step.run("send-confirmation-email", async () => {
      const user = await database.users.findById(userId);
      return await emailService.send({
        to: user.email,
        template: "order-confirmation",
        data: {
          orderId,
          items,
          total,
          trackingNumber: shipment.trackingNumber,
          estimatedDelivery: shipment.estimatedDelivery
        }
      });
    });

    // Step 9: Schedule follow-up
    await step.run("schedule-follow-up", async () => {
      return await inngest.send({
        name: "order/follow-up",
        data: { orderId },
        // Send follow-up after estimated delivery
        ts: shipment.estimatedDelivery.getTime() + (24 * 60 * 60 * 1000) // +1 day
      });
    });

    logger.info("Order processed successfully", { 
      orderId, 
      paymentId: payment.id, 
      trackingNumber: shipment.trackingNumber 
    });

    return {
      orderId,
      status: "processed",
      paymentId: payment.id,
      trackingNumber: shipment.trackingNumber
    };
  }
);
```

## Content Moderation Pipeline

**What it does**: Implements AI-powered content moderation with human review for edge cases, automatic escalation, and machine learning feedback loops.

**When to use**: Social platforms, user-generated content sites, marketplaces with reviews, or any application where content quality and safety are critical.

### Key Features

| Feature | Description | Business Value |
|---------|-------------|----------------|
| **AI + Human Hybrid** | AI handles clear cases, humans review ambiguous content | Scales moderation while maintaining quality |
| **Confidence-Based Routing** | Routes content based on AI confidence levels | Optimizes human reviewer time and accuracy |
| **SLA Management** | Enforces review timeframes with automatic escalation | Ensures consistent moderation speed |
| **Feedback Loops** | Trains AI model with human decisions | Continuously improves AI accuracy over time |
| **Priority Queuing** | Fast-tracks high-severity content for urgent review | Protects users from harmful content quickly |

### Decision Flow

```
Content Submitted → Validation → AI Analysis
                                     ↓
High Confidence (>95%) → Auto Approve/Reject
                                     ↓
Low Confidence (<95%) → Human Review Queue
                                     ↓
24hr SLA → Senior Escalation → 4hr SLA → Auto-Reject
```

### Moderation Criteria

- **Validation**: Basic format, length, and user reputation checks
- **AI Analysis**: Toxicity, spam, inappropriate content detection
- **Human Review**: Context-sensitive decisions, cultural nuances
- **Senior Review**: Complex cases, policy edge cases, appeals

### Use Cases
- **Social Media Platforms**: Posts, comments, messages moderation
- **Marketplace Reviews**: Product reviews and seller feedback
- **Community Forums**: Discussion threads and user responses
- **Creative Platforms**: User-uploaded art, videos, and stories

```typescript
type ContentSubmittedEvent = {
  name: "content/submitted";
  data: {
    contentId: string;
    userId: string;
    type: "post" | "comment" | "image" | "video";
    content: string;
    metadata?: Record<string, any>;
  };
};

export const moderateContent = inngest.createFunction(
  {
    id: "moderate-content",
    concurrency: { limit: 50 },
    rateLimit: { limit: 1000, period: "1h" }
  },
  { event: "content/submitted" },
  async ({ event, step }) => {
    const { contentId, userId, type, content } = event.data;

    // Step 1: Basic validation
    const validation = await step.run("validate-content", async () => {
      return await contentValidator.validate({
        type,
        content,
        userId
      });
    });

    if (!validation.valid) {
      await step.run("reject-invalid-content", async () => {
        return await contentService.reject(contentId, validation.reasons);
      });
      return { status: "rejected", reason: "validation_failed" };
    }

    // Step 2: AI moderation
    const aiModeration = await step.run("ai-moderation", async () => {
      return await aiModerationService.analyze({
        contentId,
        type,
        content
      });
    });

    // Step 3: Decision based on AI confidence
    if (aiModeration.confidence > 0.95) {
      if (aiModeration.decision === "approve") {
        await step.run("auto-approve", async () => {
          return await contentService.approve(contentId);
        });
        return { status: "approved", method: "ai_auto" };
      } else {
        await step.run("auto-reject", async () => {
          return await contentService.reject(contentId, aiModeration.reasons);
        });
        return { status: "rejected", method: "ai_auto", reasons: aiModeration.reasons };
      }
    }

    // Step 4: Human review for low confidence cases
    await step.run("queue-for-human-review", async () => {
      return await humanReviewQueue.add({
        contentId,
        userId,
        type,
        content,
        aiAnalysis: aiModeration,
        priority: aiModeration.severity === "high" ? "urgent" : "normal"
      });
    });

    // Step 5: Wait for human decision
    const humanDecision = await step.waitForEvent("wait-for-human-decision", {
      event: "content/human_reviewed",
      timeout: "24h", // 24-hour SLA for review
      if: `event.data.contentId == "${contentId}"`
    });

    if (!humanDecision) {
      // Timeout - escalate to senior moderator
      await step.run("escalate-review", async () => {
        return await humanReviewQueue.escalate(contentId, "senior");
      });

      // Wait for senior moderator decision
      const seniorDecision = await step.waitForEvent("wait-for-senior-decision", {
        event: "content/senior_reviewed",
        timeout: "4h",
        if: `event.data.contentId == "${contentId}"`
      });

      if (!seniorDecision) {
        // Auto-reject after timeout
        await step.run("timeout-reject", async () => {
          return await contentService.reject(contentId, ["review_timeout"]);
        });
        return { status: "rejected", method: "timeout" };
      }

      return { 
        status: seniorDecision.data.approved ? "approved" : "rejected",
        method: "senior_review",
        reviewer: seniorDecision.data.reviewerId
      };
    }

    // Step 6: Apply human decision
    if (humanDecision.data.approved) {
      await step.run("human-approve", async () => {
        return await contentService.approve(contentId);
      });
    } else {
      await step.run("human-reject", async () => {
        return await contentService.reject(contentId, humanDecision.data.reasons);
      });
    }

    // Step 7: Update AI model with human feedback
    await step.run("update-ai-model", async () => {
      return await aiModerationService.addTrainingData({
        content,
        aiPrediction: aiModeration,
        humanDecision: humanDecision.data,
        contentId
      });
    });

    return {
      status: humanDecision.data.approved ? "approved" : "rejected",
      method: "human_review",
      reviewer: humanDecision.data.reviewerId
    };
  }
);
```

## Subscription Billing Workflow

**What it does**: Handles complete subscription billing cycles with intelligent retry logic, dunning processes, and graceful subscription management.

**When to use**: SaaS applications, subscription services, membership sites, or any business with recurring billing requirements.

### Key Features

| Feature | Description | Business Value |
|---------|-------------|----------------|
| **Smart Retry Logic** | Multiple payment attempts with strategic timing | Reduces involuntary churn from temporary payment issues |
| **Dynamic Pricing** | Calculates taxes, discounts, and prorations | Ensures accurate billing across different customer scenarios |
| **Dunning Management** | Automated email sequences for failed payments | Maximizes payment recovery with minimal manual effort |
| **Customer Communication** | Proactive notifications throughout the billing process | Improves customer experience and payment success rates |
| **Graceful Cancellation** | Handles failed payments with appropriate cleanup | Maintains good customer relationships even during cancellation |

### Billing Process Flow

1. **Billing Calculation** - Compute final amount with taxes and discounts
2. **Payment Attempts** - Try payment up to 3 times with delays
3. **Success Handling** - Update subscription and send receipt
4. **Failure Management** - Start dunning process for failed payments
5. **Dunning Sequence** - 7-day → reminder → 7-day → final warning → 3-day → cancel

### Dunning Timeline

| Day | Action | Purpose |
|-----|--------|---------|
| 0 | Initial payment failure | Customer notified immediately |
| 7 | First dunning email | Gentle reminder to update payment |
| 14 | Final warning email | Urgent notice with 3-day deadline |
| 17 | Subscription cancelled | Graceful cancellation with reinstatement options |

### Use Cases
- **SaaS Platforms**: Monthly/annual subscription billing
- **Streaming Services**: Handle payment method updates and retries
- **E-learning Platforms**: Manage course subscriptions and access
- **Membership Sites**: Recurring membership fee processing

```typescript
export const processSubscriptionBilling = inngest.createFunction(
  {
    id: "process-subscription-billing",
    concurrency: { limit: 10, key: "event.data.customerId" },
    retries: 3
  },
  { event: "billing/cycle_due" },
  async ({ event, step }) => {
    const { subscriptionId, customerId, amount, dueDate } = event.data;

    // Step 1: Get customer and subscription details
    const [customer, subscription] = await Promise.all([
      step.run("fetch-customer", () => 
        customerService.getById(customerId)
      ),
      step.run("fetch-subscription", () => 
        subscriptionService.getById(subscriptionId)
      )
    ]);

    // Step 2: Calculate final amount (with taxes, discounts)
    const billing = await step.run("calculate-billing", async () => {
      return await billingCalculator.calculate({
        subscription,
        customer,
        baseAmount: amount
      });
    });

    // Step 3: Attempt payment
    let attempt = 1;
    const maxAttempts = 3;

    while (attempt <= maxAttempts) {
      const payment = await step.run(`charge-attempt-${attempt}`, async () => {
        try {
          return await paymentService.charge({
            customerId,
            amount: billing.totalAmount,
            paymentMethodId: customer.defaultPaymentMethodId,
            metadata: { subscriptionId, attempt }
          });
        } catch (error) {
          return { success: false, error: error.message, code: error.code };
        }
      });

      if (payment.success) {
        // Success - update subscription and send receipt
        await Promise.all([
          step.run("update-subscription", () =>
            subscriptionService.markPaid(subscriptionId, payment.id)
          ),
          step.run("send-receipt", () =>
            emailService.send({
              to: customer.email,
              template: "payment-receipt",
              data: { 
                amount: billing.totalAmount,
                paymentId: payment.id,
                subscription 
              }
            })
          )
        ]);

        return { 
          status: "paid",
          paymentId: payment.id,
          attempt 
        };
      }

      // Payment failed
      if (payment.code === "card_declined" && attempt < maxAttempts) {
        // Wait before retry (1 day, then 3 days)
        const waitTime = attempt === 1 ? "1d" : "3d";
        await step.sleep(`wait-before-retry-${attempt}`, waitTime);
        
        // Send retry notification
        await step.run(`send-retry-notification-${attempt}`, () =>
          emailService.send({
            to: customer.email,
            template: "payment-retry",
            data: { 
              attempt: attempt + 1,
              nextAttempt: waitTime,
              amount: billing.totalAmount 
            }
          })
        );
        
        attempt++;
      } else {
        // Permanent failure or max attempts reached
        break;
      }
    }

    // All payment attempts failed
    await step.run("handle-payment-failure", async () => {
      return await subscriptionService.markOverdue(subscriptionId);
    });

    // Start dunning process
    await step.run("start-dunning", async () => {
      return await inngest.send({
        name: "billing/dunning_start",
        data: { subscriptionId, customerId, failedAmount: billing.totalAmount }
      });
    });

    // Notify customer of failure
    await step.run("send-failure-notification", () =>
      emailService.send({
        to: customer.email,
        template: "payment-failed",
        data: { 
          amount: billing.totalAmount,
          subscription,
          updatePaymentUrl: `${process.env.APP_URL}/billing/update-payment`
        }
      })
    );

    return { 
      status: "failed",
      attempts: maxAttempts 
    };
  }
);

// Dunning process
export const dunningProcess = inngest.createFunction(
  {
    id: "dunning-process",
    concurrency: { limit: 5, key: "event.data.customerId" }
  },
  { event: "billing/dunning_start" },
  async ({ event, step }) => {
    const { subscriptionId, customerId, failedAmount } = event.data;

    // Wait 7 days
    await step.sleep("wait-7-days", "7d");

    // Check if payment was updated
    const subscription = await step.run("check-subscription-status", () =>
      subscriptionService.getById(subscriptionId)
    );

    if (subscription.status === "active") {
      return { status: "resolved", method: "customer_updated_payment" };
    }

    // Send first dunning email
    await step.run("send-dunning-email-1", () =>
      emailService.send({
        to: subscription.customer.email,
        template: "dunning-reminder-1",
        data: { subscription, failedAmount }
      })
    );

    // Wait another 7 days
    await step.sleep("wait-another-7-days", "7d");

    // Check again
    const updatedSubscription = await step.run("check-subscription-status-2", () =>
      subscriptionService.getById(subscriptionId)
    );

    if (updatedSubscription.status === "active") {
      return { status: "resolved", method: "customer_updated_payment" };
    }

    // Send final warning
    await step.run("send-final-warning", () =>
      emailService.send({
        to: subscription.customer.email,
        template: "dunning-final-warning",
        data: { subscription, cancelDate: "in 3 days" }
      })
    );

    // Wait 3 more days
    await step.sleep("wait-3-days", "3d");

    // Final check
    const finalSubscription = await step.run("final-subscription-check", () =>
      subscriptionService.getById(subscriptionId)
    );

    if (finalSubscription.status === "active") {
      return { status: "resolved", method: "customer_updated_payment" };
    }

    // Cancel subscription
    await step.run("cancel-subscription", () =>
      subscriptionService.cancel(subscriptionId, "payment_failure")
    );

    await step.run("send-cancellation-notice", () =>
      emailService.send({
        to: subscription.customer.email,
        template: "subscription-cancelled",
        data: { subscription, reason: "payment_failure" }
      })
    );

    return { status: "cancelled" };
  }
);
```

## Data Processing Pipeline

**What it does**: Processes large datasets with parallel batch processing, comprehensive error handling, and detailed result aggregation.

**When to use**: ETL operations, bulk data imports, file processing workflows, or any scenario requiring high-throughput data processing with reliability.

### Key Features

| Feature | Description | Business Value |
|---------|-------------|----------------|
| **Batch Processing** | Groups events for efficient parallel processing | Maximizes throughput while managing resource usage |
| **Parallel Execution** | Processes multiple files simultaneously | Dramatically reduces total processing time |
| **Validation & Error Handling** | Validates files before processing and handles failures gracefully | Prevents bad data from corrupting downstream systems |
| **Progress Tracking** | Detailed results with success/failure breakdown | Provides visibility into processing status and issues |
| **Configurable Batching** | Adjustable batch sizes and timeouts | Optimizes for different data volumes and processing requirements |

### Processing Strategy

- **File Validation**: Check format, size, schema compliance before processing
- **Batch Organization**: Group files into manageable batches for parallel processing
- **Error Isolation**: Failed files don't affect successful ones in the same batch
- **Result Aggregation**: Comprehensive summary with detailed failure reporting
- **Notification System**: Alerts on completion with processing statistics

### Batch Configuration

| Setting | Value | Purpose |
|---------|-------|---------|
| **Max Batch Size** | 10 files | Balance parallelism with resource usage |
| **Batch Timeout** | 30 seconds | Ensure timely processing of smaller batches |
| **Processing Batch Size** | 5 files | Parallel processing within each batch |
| **Inter-batch Delay** | 2 seconds | Prevent overwhelming downstream systems |
| **Concurrency Limit** | 5 simultaneous pipelines | Control resource consumption |

### Use Cases
- **Data Warehousing**: Process CSV/JSON imports into analytics databases
- **Media Processing**: Batch convert, resize, or analyze uploaded media files
- **Document Processing**: Extract data from PDFs, images, or other documents
- **API Data Sync**: Bulk synchronization between different systems

```typescript
export const processDataUpload = inngest.createFunction(
  {
    id: "process-data-upload",
    concurrency: { limit: 5 },
    batchEvents: { maxSize: 10, timeout: "30s" }
  },
  { event: "data/file_uploaded" },
  async ({ events, step }) => {
    const files = events.map(e => e.data);

    // Step 1: Validate all files
    const validations = await step.run("validate-files", async () => {
      return await Promise.all(
        files.map(file => fileValidator.validate(file))
      );
    });

    const validFiles = files.filter((file, index) => validations[index].valid);
    const invalidFiles = files.filter((file, index) => !validations[index].valid);

    // Notify about invalid files
    if (invalidFiles.length > 0) {
      await step.run("notify-invalid-files", () =>
        notificationService.sendBatch({
          type: "file_validation_failed",
          files: invalidFiles
        })
      );
    }

    if (validFiles.length === 0) {
      return { status: "no_valid_files" };
    }

    // Step 2: Process files in parallel batches
    const batchSize = 5;
    const batches = [];
    
    for (let i = 0; i < validFiles.length; i += batchSize) {
      batches.push(validFiles.slice(i, i + batchSize));
    }

    const results = [];
    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
      const batch = batches[batchIndex];
      
      const batchResults = await step.run(`process-batch-${batchIndex}`, async () => {
        return await Promise.all(
          batch.map(async (file) => {
            try {
              const processed = await dataProcessor.process(file);
              return { fileId: file.id, success: true, result: processed };
            } catch (error) {
              return { 
                fileId: file.id, 
                success: false, 
                error: error.message 
              };
            }
          })
        );
      });

      results.push(...batchResults);

      // Small delay between batches to avoid overwhelming downstream systems
      if (batchIndex < batches.length - 1) {
        await step.sleep(`wait-between-batches-${batchIndex}`, "2s");
      }
    }

    // Step 3: Aggregate results
    const summary = await step.run("aggregate-results", async () => {
      const successful = results.filter(r => r.success);
      const failed = results.filter(r => !r.success);

      return {
        totalFiles: validFiles.length,
        successful: successful.length,
        failed: failed.length,
        successfulFiles: successful.map(r => r.fileId),
        failedFiles: failed.map(r => ({ fileId: r.fileId, error: r.error }))
      };
    });

    // Step 4: Store results
    await step.run("store-results", () =>
      resultStore.save({
        batchId: events[0].data.batchId,
        summary,
        processedAt: new Date()
      })
    );

    // Step 5: Send completion notification
    await step.run("send-completion-notification", () =>
      notificationService.send({
        type: "batch_processing_complete",
        data: summary
      })
    );

    return summary;
  }
);
```

import { Callout } from 'nextra/components'

<Callout type="info">
**Implementation Tips**: These examples showcase production-ready patterns with comprehensive error handling. Start with simpler versions and gradually add complexity as your requirements grow. Each example can be adapted to your specific business logic and external service integrations.
</Callout>

<Callout type="warning">
**Testing Recommendation**: Always test these complex workflows thoroughly in a staging environment before deploying to production. Use Inngest's test engine to simulate various failure scenarios and edge cases.
</Callout>

## Next Steps

Now that you've seen these comprehensive examples:

- **[Testing Strategies](/quick-start/patterns#testing-functions)** - Learn how to test complex workflows effectively
- **[Error Handling Patterns](/quick-start/patterns#error-handling)** - Deep dive into robust error handling strategies  
- **[Production Best Practices](/concepts/flow-control#best-practices)** - Optimize these patterns for scale and reliability