# Functions

Functions are where your business logic lives in Inngest. Write them like regular TypeScript functions, and Inngest automatically handles the complex workflow orchestration - retries, state persistence, error handling, and scaling. Think of them as **smart functions** that respond to [Events](/concepts/events) and can pause, wait, and recover from failures without losing progress. <br/> <br/>

<img src="/function.jpg" alt="Function" />


## Anatomy of a Function

Every Inngest function consists of three essential parts that work together to create reliable, scalable workflows. This consistent structure makes functions predictable to write, debug, and maintain across your entire application.

```typescript
export const processOrder = inngest.createFunction(
  // 1. Configuration
  { 
    id: "process-order",
    concurrency: { limit: 10 },
    retries: 3
  },
  // 2. Trigger
  { event: "order/created" },
  // 3. Handler
  async ({ event, step }) => {
    // Your business logic here
  }
);
```

### Configuration

The configuration object controls how your function executes in production:

| Setting | Purpose | Example |
|---------|---------|---------|
| **ID** | Required unique identifier | `"process-order"` |
| **Name** | Optional display name for dashboard | `"Process Order"` |
| **Concurrency** | How many instances can run simultaneously | `{ limit: 5, key: "event.data.userId" }` |
| **Rate Limiting** | How frequently function can execute | `{ limit: 100, period: "1h" }` |
| **Retries** | How many times to retry on failure | `3` |
| **Batching** | Process events individually or in groups | `{ maxSize: 50, timeout: "10s" }` |
| **Error Handling** | What happens when all retries fail | `onFailure: async ({ error }) => {...}` |

```typescript
{
  id: "unique-function-id",        // Required: unique identifier
  name: "Process Order",           // Optional: display name
  concurrency: { 
    limit: 5,                      // Max concurrent executions
    key: "event.data.userId"       // Per-user limiting
  },
  retries: 3,                      // Max retry attempts
  rateLimit: {
    limit: 100,                    // 100 executions
    period: "1h"                   // Per hour
  },
  batchEvents: {
    maxSize: 50,                   // Batch up to 50 events
    timeout: "10s"                 // Or after 10 seconds
  }
}
```

### Triggers

Triggers define **when** your function should execute. They're like powerful event listeners that can respond to multiple types of inputs:

| Trigger Type | Purpose | Example Use Case |
|--------------|---------|------------------|
| **Event** | Respond to things happening in your app | User signup, order created, payment completed |
| **Schedule (Cron)** | Run on a time schedule | Daily reports, weekly cleanups, monthly billing |
| **Multiple Events** | Respond to different related events | Both "user/created" and "user/updated" |
| **Pattern Matching** | Respond to event families | All events starting with "user/" |

**Key Benefits:**
- One function can have multiple triggers
- Functions automatically scale based on incoming events
- No infrastructure setup required - just define what should trigger execution

```typescript
// Event trigger
{ event: "user/signup" }

// Multiple events
{ event: ["user/signup", "user/created"] }

// Event pattern matching
{ event: "user/*" }

// Cron schedule
{ cron: "0 9 * * *" }  // Daily at 9 AM

// Multiple triggers
[
  { event: "order/created" },
  { cron: "0 */6 * * *" }  // Every 6 hours
]
```

### Handler Function

The handler contains your business logic and receives powerful tools for building reliable workflows:

**Function Parameters:**

| Parameter | Purpose | What You Get |
|-----------|---------|--------------|
| `event` | The data that triggered this function | Event name, payload data, timestamp, unique ID |
| `step` | Durable execution tools | `run()`, `sleep()`, `waitForEvent()`, `invoke()` for checkpoints |
| `logger` | Structured logging | Logs that appear in Inngest dashboard with context |
| `runId` | Unique execution identifier | Track this specific function run across systems |

**Why the `step` object matters:**
- **Checkpoints**: Each `step.run()` saves progress - if step 3 fails, steps 1-2 don't re-execute
- **Reliability**: Failed steps retry automatically with exponential backoff
- **Visibility**: Every step appears in the Inngest dashboard for debugging

```typescript
async ({ event, step, logger, runId }) => {
  // event: The triggering event data
  // step: Durable execution primitives
  // logger: Structured logging
  // runId: Unique execution identifier
}
```

## Function Types

Functions serve different purposes depending on how and when they execute. Each type solves specific workflow challenges and provides different execution guarantees.

### Background Functions
Process work outside your API request flow to keep responses fast. These functions handle time-consuming tasks like sending emails, processing images, or syncing data with external APIs.

By moving this work to the background, your users get instant API responses while the heavy lifting happens asynchronously. Perfect for any work that doesn't need to complete before responding to a user request.

```typescript
export const sendWelcomeEmail = inngest.createFunction(
  { id: "send-welcome-email" },
  { event: "user/signup" },
  async ({ event, step }) => {
    const user = await step.run("fetch-user", () => 
      db.users.findById(event.data.userId)
    );

    await step.run("send-email", () => 
      emailService.send({ to: user.email, template: "welcome" })
    );
  }
);
```

### Scheduled Functions
Run tasks on a time-based schedule, similar to cron jobs but with built-in reliability and observability. These functions are ideal for recurring maintenance tasks, generating reports, or cleaning up expired records.

Unlike traditional cron jobs, scheduled functions automatically retry on failure, log their execution, and provide visibility into their performance.

```typescript
export const generateDailyReport = inngest.createFunction(
  { id: "daily-report" },
  { cron: "0 9 * * *" },
  async ({ step }) => {
    const data = await step.run("collect-data", () => 
      analytics.getYesterdayStats()
    );

    await step.run("send-report", () => 
      emailService.send({ to: ["team@company.com"], data })
    );
  }
);
```

### Multi-Step Workflows
Break complex processes into reliable, resumable steps that can span minutes, hours, or even days. Each step creates a checkpoint, so if anything fails partway through, the workflow resumes from the last successful step rather than starting over.

This is crucial for processes involving external APIs, payments, approvals, or any multi-stage business logic where partial completion would be problematic.

```typescript
export const processPayment = inngest.createFunction(
  { id: "process-payment" },
  { event: "payment/requested" },
  async ({ event, step }) => {
    // Validate payment
    const validation = await step.run("validate", () => 
      paymentValidator.validate(event.data)
    );

    if (!validation.valid) {
      throw new Error(`Invalid payment: ${validation.errors.join(", ")}`);
    }

    // Process payment
    const payment = await step.run("charge", () => 
      paymentProcessor.charge(event.data)
    );

    // Send confirmation
    await step.run("confirm", () => 
      emailService.send({ 
        to: event.data.userEmail, 
        template: "payment-success",
        data: { transactionId: payment.id }
      })
    );

    return { paymentId: payment.id, status: "completed" };
  }
);
```

## Advanced Configuration

Fine-tune how your functions execute in production to protect your infrastructure and external services. These settings help you manage load, prevent overwhelming APIs, and ensure fair resource allocation.

```typescript
{
  // Limit concurrent executions
  concurrency: { limit: 5, key: "event.data.userId" },
  
  // Control execution frequency  
  rateLimit: { limit: 100, period: "1h" },
  
  // Process events in batches
  batchEvents: { maxSize: 50, timeout: "10s" },
  
  // Handle failures
  retries: 3,
  onFailure: async ({ error }) => alerting.send(error.message)
}
```

## Function Composition

Build complex workflows by connecting functions together into larger business processes. Function composition allows you to create modular, reusable workflows where each function has a single responsibility.

You can invoke other functions synchronously to wait for their completion, or trigger them asynchronously to create parallel processing pipelines.

### Calling Other Functions
Use `step.invoke()` to call other functions and wait for their results. This creates a parent-child relationship where the calling function waits for the invoked function to complete before continuing.

```typescript
export const orderWorkflow = inngest.createFunction(
  { id: "order-workflow" },
  { event: "order/created" },
  async ({ event, step }) => {
    const payment = await step.invoke("process-payment", {
      function: processPaymentFunction,
      data: event.data
    });

    const fulfillment = await step.invoke("fulfill-order", {
      function: fulfillOrderFunction,
      data: { orderId: event.data.orderId, paymentId: payment.id }
    });

    return { payment, fulfillment };
  }
);
```

## Testing Functions

Test your functions like any other TypeScript code, with additional tools specifically designed for Inngest workflows. Unit testing focuses on the business logic within each step, using mocks to isolate external dependencies.

Integration testing verifies that functions work correctly with real Inngest infrastructure, including event triggering, step execution, and function composition.

```typescript
// Unit testing with mocks
import { createStepTools } from "inngest/test";

const { step } = createStepTools();
step.run.mockResolvedValue({ id: "payment_123" });

const result = await processOrder.handler({ event: mockEvent, step });

// Integration testing with test engine  
import { InngestTestEngine } from "inngest/test";

const t = new InngestTestEngine({ functions: [processOrder] });
await t.send({ name: "order/created", data: { orderId: "123" } });
const runs = await t.waitForRuns("process-order");
```

import { Callout } from 'nextra/components'

<Callout type="info">
**Performance Tip**: Functions scale automatically, but use concurrency limits to protect downstream services from overload.
</Callout>

<Callout type="warning">
**Important**: Each step creates a checkpoint. Failed steps retry automatically, but successful steps never re-execute.
</Callout>

## Next Steps

- Learn about [Steps](/concepts/steps) for building durable workflows
- Explore [Flow Control](/concepts/flow-control) for advanced execution management
- See [Real-World Examples](/quick-start/examples) of function patterns 