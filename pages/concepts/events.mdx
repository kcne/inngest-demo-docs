# Events

Events are the heartbeat of Inngest's event-driven architecture. They represent immutable records of things that happen in your system - user signups, order completions, file uploads, or any significant state change. Think of events as **announcements**: "Hey, something important just happened!" Your [Functions](/concepts/functions) listen for these announcements and automatically spring into action. <br/> <br/>

<img src="/events.png" alt="Events" />

## Why Events Matter

Events solve a fundamental problem in application architecture: **tight coupling between your core application and background processing**. Without events, your API routes become bloated with background work, making them slow and brittle. Events decouple these concerns, allowing your application to respond instantly while background work happens reliably in parallel.

### Without Events (Traditional Queue System)
```typescript
// Complex setup required
const Queue = require('bull');
const emailQueue = new Queue('email', process.env.REDIS_URL);
const analyticsQueue = new Queue('analytics', process.env.REDIS_URL);

// API route
app.post('/api/users', async (req, res) => {
  const user = await db.users.create(req.body);
  
  // Add jobs to different queues
  await emailQueue.add('welcome', { email: user.email });
  await analyticsQueue.add('track', { userId: user.id, event: 'user_created' });
  
  res.json(user);
});

// Separate worker processes needed
emailQueue.process('welcome', async (job) => {
  // If this fails, job restarts from scratch
  await emailService.sendWelcome(job.data.email);
});

analyticsQueue.process('track', async (job) => {
  // Separate error handling for each queue
  try {
    await analyticsService.track(job.data.event, job.data.userId);
  } catch (error) {
    // Manual retry logic needed
    throw new Error('Analytics failed');
  }
});
```

### With Events (Inngest)
```typescript
// API route
app.post('/api/users', async (req, res) => {
  const user = await db.users.create(req.body);
  
  // Just announce what happened
  await inngest.send({
    name: "user/created",
    data: { userId: user.id, email: user.email }
  });
  
  res.json(user);
});

// Functions handle the rest automatically
export const sendWelcomeEmail = inngest.createFunction(
  { id: "send-welcome" },
  { event: "user/created" },
  async ({ event }) => await emailService.sendWelcome(event.data.email)
);

export const trackUser = inngest.createFunction(
  { id: "track-user" },
  { event: "user/created" },
  async ({ event }) => await analyticsService.track('user_created', event.data.userId)
);
```

**The result**: Your API is fast, your background work is reliable, and adding new workflows doesn't require changing existing code.

## Event Structure

Every Inngest event has a simple structure that makes them easy to work with and debug. This consistent format means your functions always know what to expect, and you can inspect events easily in the Inngest dashboard. The structure follows a predictable pattern that scales from simple notifications to complex workflow triggers.

```typescript
{
  name: "user/signup",           // Event identifier (required)
  data: {                       // Your payload (optional)
    userId: "usr_123",
    email: "jane@example.com"
  }
}
```

**Key Components:**
- **Name**: Use clear, hierarchical names like `user/signup`, `order/created`, `payment/completed`
- **Data**: Include everything your functions need - events are immutable, so you can't add data later
- **Consistency**: The same structure across all events makes your code predictable and maintainable

## Sending Events

Events can be sent from anywhere in your application, providing maximum flexibility for triggering workflows. This decoupling means you can emit events from API routes, database triggers, webhooks, or background jobs without worrying about where the processing happens. The flexibility allows your workflows to respond to changes no matter where they originate in your system.

**Common Sources:**
```typescript
// From API routes
await inngest.send({
  name: "order/created",
  data: { orderId: order.id, userId: order.userId }
});

// From database triggers  
await inngest.send({
  name: "user/created", 
  data: { userId: result.id, email: result.email }
});

// From webhooks
await inngest.send({
  name: `payment/${event.type}`,
  data: event.data.object
});

// Batch sending for efficiency
await inngest.send([
  { name: "user/updated", data: { userId: "123" } },
  { name: "profile/completed", data: { userId: "123" } }
]);
```

**Learn more**: [Official Events & Triggers Guide](https://www.inngest.com/docs/features/events-triggers)

## Common Patterns

Here are the most useful event patterns that solve common workflow challenges. These patterns help you build scalable, maintainable systems by organizing how events flow through your application. Understanding these patterns is essential for designing robust event-driven architectures that can grow with your application.

### Fan-Out
One event triggers multiple independent functions, allowing you to process different aspects of the same occurrence in parallel. This pattern is perfect for user signups where you need to send emails, track analytics, create billing records, and perform other independent tasks. Each function operates independently, so if one fails, others continue processing successfully.

```typescript
// One event...
await inngest.send({ name: "user/signup", data: { userId: "123" } });

// ...triggers multiple functions
export const sendWelcome = inngest.createFunction(
  { id: "welcome" }, { event: "user/signup" },
  async ({ event }) => { /* send email */ }
);

export const trackSignup = inngest.createFunction(
  { id: "track" }, { event: "user/signup" },
  async ({ event }) => { /* analytics */ }
);
```

### Event Chains
Functions can trigger other functions by sending new events, creating sequential workflows where each step builds on the previous one. This pattern is ideal for complex business processes that have natural dependencies, like order processing where payment must complete before fulfillment begins. Event chains provide clear separation of concerns while maintaining workflow integrity.

```typescript
export const processPayment = inngest.createFunction(
  { id: "process-payment" },
  { event: "order/created" },
  async ({ event, step }) => {
    await step.run("charge", () => stripe.charge(event.data.total));
    
    // Trigger next workflow
    await step.run("trigger-fulfillment", () =>
      inngest.send({ name: "order/paid", data: event.data })
    );
  }
);
```

**Learn more**: [Function triggers in detail](/concepts/functions#triggers)

## Debugging Events

Use the Inngest Dev Server to inspect events in real-time and debug your workflows. The dev server provides a visual interface showing all events flowing through your system, which functions they trigger, and the results of each execution. This visibility is crucial for understanding event flow and troubleshooting issues in your workflows.

```bash
npx inngest-cli dev
# Open http://localhost:8288 to see events in real-time
```

**What you can debug:**
- **Event flow**: See which events are being sent and when
- **Function triggers**: Verify that events are triggering the correct functions  
- **Execution results**: Monitor function success, failures, and retry attempts
- **Payload inspection**: Examine event data to ensure it contains the expected information

## Next Steps

Now that you understand events, learn how they trigger workflows:

**[→ Functions: Building Workflows](/concepts/functions)**

Functions are where your business logic lives. They respond to events and orchestrate complex workflows using [Steps](/concepts/steps) for durability.

**Also explore:**
- [Real-World Examples](/quick-start/examples) - See events in complete workflows
- [Patterns & Anti-Patterns](/quick-start/patterns) - Event design best practices
- [Official Events Documentation](https://www.inngest.com/docs/features/events-triggers) - Complete technical reference 

## Event Matching and Filtering

Functions can listen to events in sophisticated ways beyond simple name matching. Event matching allows you to build flexible workflows that respond to specific conditions, multiple event types, or event families. This flexibility is crucial for building maintainable event-driven systems that can evolve with your business logic.

### Pattern Matching
Listen to multiple related events using wildcards:

```typescript
// Listen to all user events
export const userEventHandler = inngest.createFunction(
  { id: "user-event-handler" },
  { event: "user/*" },  // Matches user/created, user/updated, user/deleted
  async ({ event, step }) => {
    await step.run("log-user-event", () =>
      auditLog.record(event.name, event.data)
    );
  }
);

// Listen to specific event patterns
export const orderEventHandler = inngest.createFunction(
  { id: "order-events" },
  { event: "order/{created,updated,cancelled}" },
  async ({ event, step }) => {
    await step.run("update-analytics", () =>
      analytics.trackOrderEvent(event.name, event.data)
    );
  }
);
```

### Multiple Event Types
One function can respond to different events:

```typescript
export const notificationHandler = inngest.createFunction(
  { id: "notifications" },
  { event: ["user/signup", "order/completed", "payment/failed"] },
  async ({ event, step }) => {
    await step.run("send-notification", () => {
      switch (event.name) {
        case "user/signup":
          return sendWelcomeNotification(event.data);
        case "order/completed":
          return sendOrderConfirmation(event.data);
        case "payment/failed":
          return sendPaymentAlert(event.data);
      }
    });
  }
);
```

### Conditional Matching
Use expressions to filter events based on data:

```typescript
export const highValueOrderProcessor = inngest.createFunction(
  { id: "high-value-orders" },
  { 
    event: "order/created",
    if: "event.data.total > 1000"  // Only orders over $1000
  },
  async ({ event, step }) => {
    await step.run("flag-for-review", () =>
      fraudReview.flagOrder(event.data.orderId)
    );
    
    await step.run("assign-vip-support", () =>
      support.assignVIP(event.data.customerId)
    );
  }
);
```

## Event Payload Best Practices

Designing effective event payloads is crucial for maintainable, scalable event-driven systems. Well-structured event data makes your functions more reliable, easier to debug, and simpler to evolve over time. Consider these guidelines when designing your event payloads.

### What to Include
**Essential Data:**
- **Identifiers**: Always include relevant IDs (userId, orderId, etc.)
- **Timestamps**: When the event occurred (often auto-generated)
- **Context**: Enough data for functions to do their work without additional API calls
- **Metadata**: Information about the source, version, or correlation IDs

```typescript
// ✅ Good - Rich, self-contained event
await inngest.send({
  name: "order/created",
  data: {
    orderId: "ord_123",
    userId: "usr_456",
    total: 99.99,
    currency: "USD",
    items: [
      { productId: "prod_789", quantity: 2, price: 49.99 }
    ],
    shippingAddress: {
      country: "US",
      state: "CA",
      zipCode: "94105"
    },
    paymentMethod: "card",
    source: "web"
  }
});
```

### What to Avoid
**Problematic Patterns:**
- **Sensitive data**: Credit card numbers, passwords, personal information
- **Large payloads**: Files, images, or massive datasets (use references instead)
- **Internal details**: Database schemas, internal IDs that could change
- **Computed values**: Data that can be derived from other fields

```typescript
// ❌ Bad - Sensitive and unnecessary data
await inngest.send({
  name: "payment/processed",
  data: {
    orderId: "ord_123",
    creditCardNumber: "4111111111111111", // ❌ Sensitive
    internalDatabaseId: 98765,            // ❌ Internal detail
    largeImageData: "base64...",          // ❌ Too large
    calculatedTax: 8.99                   // ❌ Can be computed
  }
});

// ✅ Better - Clean, secure, essential data
await inngest.send({
  name: "payment/processed",
  data: {
    orderId: "ord_123",
    paymentId: "pay_789",
    amount: 99.99,
    currency: "USD",
    status: "succeeded"
  }
});
```

### Size and Performance
**Event Limits:**
- Keep events under 64KB for optimal performance
- Use references for large data (store in database, reference by ID)
- Consider pagination for arrays with many items
- Batch related events when possible

## Error Handling for Events

Event sending and processing can fail for various reasons, from network issues to validation errors. Understanding how to handle these failures gracefully is essential for building robust event-driven systems. Proper error handling ensures your events are delivered reliably and your workflows can recover from failures.

### Event Sending Failures
Handle failures when sending events to Inngest:

```typescript
export async function createUser(userData) {
  try {
    // Create user in database first
    const user = await db.users.create(userData);
    
    // Then send event
    await inngest.send({
      name: "user/created",
      data: { userId: user.id, email: user.email }
    });
    
    return user;
  } catch (error) {
    if (error.name === 'InngestEventError') {
      // Event sending failed - user was created but event wasn't sent
      logger.error('Failed to send user/created event', {
        userId: user.id,
        error: error.message
      });
      
      // Could implement retry logic or manual event sending
      await retryEventSending(user);
    }
    throw error;
  }
}
```

### Retry Strategies
Implement robust retry logic for critical events:

```typescript
async function sendEventWithRetry(event, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      await inngest.send(event);
      return; // Success!
    } catch (error) {
      if (attempt === maxRetries) {
        // Final attempt failed
        logger.error('Event sending failed after all retries', {
          event: event.name,
          attempts: maxRetries,
          error: error.message
        });
        
        // Could store in dead letter queue for manual processing
        await deadLetterQueue.add(event);
        throw error;
      }
      
      // Wait before retry (exponential backoff)
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### Function Error Handling
Handle errors within event-triggered functions:

```typescript
export const processOrder = inngest.createFunction(
  { id: "process-order" },
  { event: "order/created" },
  async ({ event, step }) => {
    try {
      const order = await step.run("fetch-order", () =>
        orderService.getById(event.data.orderId)
      );
      
      if (!order) {
        // Non-retryable error - order doesn't exist
        throw new NonRetriableError(`Order ${event.data.orderId} not found`);
      }
      
      await step.run("process-payment", () =>
        paymentService.process(order)
      );
      
    } catch (error) {
      // Log the error with context
      console.error('Order processing failed', {
        orderId: event.data.orderId,
        error: error.message,
        retryable: !(error instanceof NonRetriableError)
      });
      
      // Re-throw to trigger Inngest's retry logic
      throw error;
    }
  }
);
```

## Testing Events

Testing event-driven systems requires different strategies than traditional request-response testing. You need to verify that events are sent correctly, functions are triggered properly, and workflows complete successfully. Effective testing ensures your event-driven architecture works reliably in production.

### Unit Testing Event Sending
Test that your code sends the correct events:

```typescript
// userService.test.ts
import { inngest } from './inngest';

// Mock inngest.send
jest.mock('./inngest', () => ({
  inngest: {
    send: jest.fn()
  }
}));

describe('UserService', () => {
  it('sends user/created event when user is created', async () => {
    const userData = { email: 'test@example.com', name: 'Test User' };
    
    const user = await userService.create(userData);
    
    expect(inngest.send).toHaveBeenCalledWith({
      name: 'user/created',
      data: {
        userId: user.id,
        email: user.email,
        name: user.name
      }
    });
  });
});
```

### Integration Testing with Test Engine
Test complete workflows using Inngest's test engine:

```typescript
// workflow.integration.test.ts
import { InngestTestEngine } from "inngest/test";
import { processOrder, sendConfirmation } from "./functions";

describe('Order Processing Workflow', () => {
  let testEngine: InngestTestEngine;

  beforeEach(() => {
    testEngine = new InngestTestEngine({
      functions: [processOrder, sendConfirmation]
    });
  });

  it('processes order and sends confirmation', async () => {
    // Send the triggering event
    await testEngine.send({
      name: "order/created",
      data: { orderId: "ord_123", userId: "usr_456", total: 99.99 }
    });

    // Wait for functions to complete
    const processOrderRuns = await testEngine.waitForRuns("process-order");
    expect(processOrderRuns).toHaveLength(1);
    expect(processOrderRuns[0].status).toBe("completed");

    // Check that downstream functions were triggered
    const confirmationRuns = await testEngine.waitForRuns("send-confirmation");
    expect(confirmationRuns).toHaveLength(1);
    expect(confirmationRuns[0].status).toBe("completed");
  });

  it('handles payment failures gracefully', async () => {
    // Mock payment service to fail
    jest.spyOn(paymentService, 'process').mockRejectedValue(
      new Error('Payment failed')
    );

    await testEngine.send({
      name: "order/created",
      data: { orderId: "ord_123" }
    });

    const runs = await testEngine.waitForRuns("process-order");
    expect(runs[0].status).toBe("failed");
    
    // Verify retry behavior
    expect(runs[0].attempts).toBeGreaterThan(1);
  });
});
```

### Testing Event Patterns
Verify that functions respond to the correct events:

```typescript
describe('Event Pattern Matching', () => {
  it('user event handler responds to all user events', async () => {
    const events = [
      { name: "user/created", data: { userId: "123" } },
      { name: "user/updated", data: { userId: "123" } },
      { name: "user/deleted", data: { userId: "123" } },
      { name: "order/created", data: { orderId: "456" } } // Should not trigger
    ];

    for (const event of events) {
      await testEngine.send(event);
    }

    const runs = await testEngine.waitForRuns("user-event-handler");
    
    // Should have 3 runs (only user/* events)
    expect(runs).toHaveLength(3);
    expect(runs.map(r => r.event.name)).toEqual([
      "user/created", "user/updated", "user/deleted"
    ]);
  });
});
```

## Performance Considerations

Event performance impacts your entire system's responsiveness and cost. Understanding how to optimize event sending, sizing, and processing helps you build efficient, scalable event-driven architectures. Proper performance optimization ensures your events don't become a bottleneck as your system grows.

### Batch Event Sending
Send multiple events efficiently to reduce overhead:

```typescript
// ✅ Efficient - Batch multiple related events
const events = users.map(user => ({
  name: "user/created",
  data: { userId: user.id, email: user.email }
}));

await inngest.send(events); // Single API call

// ❌ Inefficient - Individual sends
for (const user of users) {
  await inngest.send({
    name: "user/created", 
    data: { userId: user.id, email: user.email }
  });
}
```

### Event Size Optimization
Keep events lean for better performance:

```typescript
// ✅ Optimized - Reference large data
await inngest.send({
  name: "document/processed",
  data: {
    documentId: "doc_123",
    userId: "usr_456",
    processingResult: "completed",
    // Reference instead of including large data
    resultUrl: "https://storage.example.com/results/doc_123.json"
  }
});

// ❌ Poor performance - Large embedded data
await inngest.send({
  name: "document/processed", 
  data: {
    documentId: "doc_123",
    largeProcessingResult: {
      // 50KB of data - too large for events
      pages: [...], // Massive array
      fullText: "...", // Complete document text
      metadata: {...} // Extensive metadata
    }
  }
});
```

### Async Event Sending
Don't block user requests with event sending:

```typescript
// ✅ Good - Fire and forget for non-critical events
app.post('/api/pageview', async (req, res) => {
  // Respond immediately
  res.json({ success: true });
  
  // Send analytics event asynchronously
  setImmediate(async () => {
    try {
      await inngest.send({
        name: "analytics/pageview",
        data: { userId: req.user.id, page: req.body.page }
      });
    } catch (error) {
      // Log but don't fail the request
      logger.error('Failed to send pageview event', error);
    }
  });
});

// ✅ Better - Use background job for guaranteed delivery
app.post('/api/critical-action', async (req, res) => {
  const result = await performCriticalAction(req.body);
  
  // Queue event for reliable background sending
  await eventQueue.add('send-event', {
    name: "action/completed",
    data: { actionId: result.id, userId: req.user.id }
  });
  
  res.json(result);
});
``` 